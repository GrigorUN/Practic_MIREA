import pandas as pd
import numpy as np

df = pd.DataFrame({
    'Средний чек (руб.)': [2300, 1800, 1700, 1200, 800, 1950, 500, 2600, 1400, 3500],
    'Удалённость локации (км)': [4.30, 2.30, 2.70, 1.60, 9.30, 2, 11.10, 2.30, 5.80, 3.20],
    'Количество услуг': [16, 17, 20, 13, 8, 16, 4, 22, 16, 19],
    'Рейтинг (от 1 до 5)': [4.80, 5, 4.90, 4.40, 3.80, 5, 2.70, 4.90, 4.80, 4.70]
    })

df.index = ['A1', 'A2', 'A3', 'A4', 'A5', 'A6', 'A7', 'A8', 'A9', 'A10']
print(df)

df['Средний чек (руб.)'] = 1 / df['Средний чек (руб.)']
df['Удалённость локации (км)'] = 1 / df['Удалённость локации (км)']

# Создаем массив для хранения результатов попарного сравнения
arr1 = np.zeros((10, 10), dtype=object)

# Попарное сравнение альтернатив
for i in range(10):
    for j in range(i + 1, 10):
        arr = df.iloc[i].values >= df.iloc[j].values  # Сравнение значений всех столбцов для альтернативы i и j
        check = all(arr)  # Проверка, что все критерии для i лучше или равны j
        arr2 = df.iloc[i].values <= df.iloc[j].values  # Сравнение значений всех столбцов для альтернативы i и j
        check2 = all(arr2)  # Проверка, что все критерии для i хуже или равны j
        # Запись результата в массив arr1
        if check:
            arr1[j, i] = 'A' + str(i + 1)
        elif check2:
            arr1[j, i] = 'A' + str(j + 1)
        else:
            arr1[j, i] = 'н'

# Создаем новый DataFrame для результатов попарного сравнения
df_ = pd.DataFrame(arr1, columns=['A1', 'A2', 'A3', 'A4', 'A5', 'A6', 'A7', 'A8', 'A9', 'A10'], 
                   index=['A1', 'A2', 'A3', 'A4', 'A5', 'A6', 'A7', 'A8', 'A9', 'A10'])

print("\n Таблица Попарное сравнение альтернатив: ")
print(df_)

print("\n Вывод парето-оптимальных альтернатив")
print(df.iloc[[1, 2, 5, 7]])

df['Средний чек (руб.)'] = 1 / df['Средний чек (руб.)']
df['Удалённость локации (км)'] = 1 / df['Удалённость локации (км)']

print("\n Результат указания верхней/нижней границы: ('Средний чек (руб.)' >= 1700 , 'Удалённость локации (км)' < 4.30)")
print(df[(df['Средний чек (руб.)'] >= 1700) & (df['Удалённость локации (км)'] < 4.30)])

print(
    "\n Результат отбора вариантов, удовлетворяющих заданным критериям: главный критерий: \n Средний чек (руб.) >= 1200, Рейтинг (от 1 до 5) >= 4.6, Удалённость локации (км) < 2.70")
print(df[(df['Средний чек (руб.)'] >= 1200) & (df['Рейтинг (от 1 до 5)'] >= 4.6) & (df['Удалённость локации (км)'] < 2.70)])

df['Средний чек (руб.)'] = 1 / df['Средний чек (руб.)']
df['Удалённость локации (км)'] = 1 / df['Удалённость локации (км)']


def lex_optimization(df):
    max_crit = df['Количество услуг'].max()  # Нахождение максимального значения в столбце 'Количество услуг'
    optimal_df = df[df['Количество услуг'] == max_crit]  # Фильтрация данных по максимальному значению количества услуг

    if len(optimal_df) == 1:  # Проверка, если найден только один оптимальный вариант
        return optimal_df

    next_crit = optimal_df['Удалённость локации (км)'].max()  # Нахождение следующего критерия - максимального значения удаленности локации
    optimal_df = optimal_df[optimal_df['Удалённость локации (км)'] == next_crit]  # Дополнительная фильтрация данных по максимальному значению удаленности локации

    return optimal_df 


result = lex_optimization(df)

print("\n Результат лексикографической оптимизации: (Самая важная: Количество услуг)")
print(result)
